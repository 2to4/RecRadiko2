# サンドボックス対応ガイド

## 問題の概要

macOSアプリのサンドボックス環境では、アプリがアクセスできるファイルシステムの場所が制限されています。これにより、CacheServiceのテストが失敗しています。

## 解決方法

### 方法1: テスト用のメモリベースキャッシュ実装

テスト環境でファイルシステムを使用せず、メモリ内でキャッシュを管理する実装を作成します。

```swift
// TestCacheService.swift
#if DEBUG
class TestCacheService: CacheServiceProtocol {
    private var cache: [String: (data: Data, expiresAt: Date)] = [:]
    
    func save<T: Codable>(_ object: T, for policy: CachePolicy) throws {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let data = try encoder.encode(object)
        let key = cacheKey(for: policy)
        cache[key] = (data: data, expiresAt: Date().addingTimeInterval(policy.expiration))
    }
    
    func load<T: Codable>(_ type: T.Type, for policy: CachePolicy) throws -> T? {
        let key = cacheKey(for: policy)
        guard let cached = cache[key],
              cached.expiresAt > Date() else {
            return nil
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return try decoder.decode(type, from: cached.data)
    }
    
    func invalidate(policy: CachePolicy) {
        let key = cacheKey(for: policy)
        cache.removeValue(forKey: key)
    }
    
    func invalidateAll() {
        cache.removeAll()
    }
    
    func cacheInfo(for policy: CachePolicy) -> CacheInfo? {
        let key = cacheKey(for: policy)
        guard let cached = cache[key] else { return nil }
        
        let attributes = [FileAttributeKey.size: cached.data.count]
        return CacheInfo(
            policy: policy,
            fileAttributes: attributes,
            expiresAt: cached.expiresAt
        )
    }
    
    private func cacheKey(for policy: CachePolicy) -> String {
        return policy.key
    }
}
#endif
```

### 方法2: アプリケーションサポートディレクトリの使用

キャッシュディレクトリの代わりに、アプリケーションサポートディレクトリを使用します。

```swift
// CacheService.swift の修正
init() throws {
    let fileManager = FileManager.default
    
    // アプリケーションサポートディレクトリを使用
    let paths = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask)
    guard let supportPath = paths.first else {
        throw CacheError.directoryNotFound
    }
    
    // バンドルIDを使用してアプリ専用ディレクトリを作成
    let bundleID = Bundle.main.bundleIdentifier ?? "com.futo4.app.RecRadiko2"
    cacheDirectory = supportPath.appendingPathComponent(bundleID, isDirectory: true)
        .appendingPathComponent("Cache", isDirectory: true)
    
    if !fileManager.fileExists(atPath: cacheDirectory.path) {
        try fileManager.createDirectory(at: cacheDirectory,
                                      withIntermediateDirectories: true)
    }
}
```

### 方法3: エンタイトルメントの追加（実装済み）

以下のエンタイトルメントを追加済み：
- `com.apple.security.files.downloads.read-write`: ダウンロードフォルダへの読み書き
- `com.apple.security.temporary-exception.files.absolute-path.read-write`: /tmp/への読み書き

## 推奨される実装

### 1. プロトコルベースの設計

```swift
protocol CacheStorageProtocol {
    func save(data: Data, to key: String) throws
    func load(from key: String) throws -> Data?
    func remove(key: String) throws
    func removeAll() throws
}

// 本番用：ファイルベース
class FileCacheStorage: CacheStorageProtocol { ... }

// テスト用：メモリベース
class MemoryCacheStorage: CacheStorageProtocol { ... }
```

### 2. 依存性注入

```swift
class CacheService: CacheServiceProtocol {
    private let storage: CacheStorageProtocol
    
    init(storage: CacheStorageProtocol? = nil) throws {
        self.storage = storage ?? try FileCacheStorage()
    }
}
```

### 3. テストでの使用

```swift
@Test
func testCacheService() throws {
    let memoryStorage = MemoryCacheStorage()
    let cacheService = try CacheService(storage: memoryStorage)
    
    // テスト実行
}
```

## エンタイトルメント設定

### 現在の設定（RecRadiko2.entitlements）
```xml
<key>com.apple.security.app-sandbox</key>
<true/>
<key>com.apple.security.files.user-selected.read-only</key>
<true/>
<key>com.apple.security.files.downloads.read-write</key>
<true/>
<key>com.apple.security.temporary-exception.files.absolute-path.read-write</key>
<array>
    <string>/tmp/</string>
</array>
```

### 追加可能なエンタイトルメント
```xml
<!-- アプリケーションサポートディレクトリへのアクセス -->
<key>com.apple.security.files.user-selected.read-write</key>
<true/>

<!-- ネットワークアクセス（Radiko API用） -->
<key>com.apple.security.network.client</key>
<true/>
```

## テスト実行時の注意事項

1. **ファイルシステムテストの分離**
   - ファイルシステムを使用するテストは別のテストターゲットに分離
   - CI/CD環境での実行を考慮

2. **モックの活用**
   - ファイルシステムに依存しないモック実装を使用
   - プロトコルベースの設計で切り替え可能に

3. **一時ディレクトリの使用**
   - テスト時は`FileManager.temporaryDirectory`を使用
   - テスト終了時に必ずクリーンアップ

## まとめ

サンドボックス環境でのファイルアクセス問題は、以下の方法で解決できます：

1. **短期的解決**: メモリベースのテスト用実装を使用
2. **中期的解決**: アプリケーションサポートディレクトリへの移行
3. **長期的解決**: プロトコルベースの設計で環境に応じた実装の切り替え

これにより、セキュアなサンドボックス環境を維持しながら、テストの信頼性も確保できます。